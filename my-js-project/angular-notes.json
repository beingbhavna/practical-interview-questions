1) Angular - Angular is a popular, open-source front-end javascript framework developed by google.it is primarily used to build single page applicaions and dynamic web applications. angular utilize typescript and provide a structured way to develop web applications.
features of angular - 
i) Component-based Architecture
ii) Declarative Templates
iii) Two-way Data Binding
iv) Dependency Injection
v) Routing
vi) Directives
vii) Services
viii) Rxjs and Obsrvables
ix) Forms
x) CLI(Command Line Interface)
xi) Lazy Loading
xii) Testing

2) What is a single page application - Single page application is a type of web application or website that interacts with the user by dynamically rewriting the current page, rather than loading entire pages from the server.

3) Components - Components are the fundamental building blocks of angular application.it is a part of the user inteface. each component typically consists of the following key elements - 
                      @Component({
                        selector:'app-component',
                        templateUrl:'./app-component.htnl',
                        styleUrls:['./app-component-css']
                      })

4) Templates - Template is a part of the component that defines the view or the UI structure. it is written in html.and they are a combination of satndard HTML markup language and angular syntax, which allows for dynamic data display and interaction.
there are some key features of templates -
i) Data Binding
ii) Directives
iii) Event Binding
iv) Pipes
v) Template Expressions
vi) Template Refrence Variables
vii) ngIf, ngFor and ngSwitch

5) Modules - These are fundamental building blocks that organize the application into cohesive blocks of functionality.They help angular understand how to compile and launch the application by organizing the various components, services, directives, pipes, and other modules into a structured way.
modules are defined using @NgModule decorators
* Dependency injection - (Services and providers).
* Component management - (Which components are the part of the module).
* Routing - (Configuring navigation for the application).
* Pipes and Directives - (custom pipes and decorators that can be shared across components).

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
Basic Structure of a Module -

                  @NgModule({
                    declarations: [
                      AppComponent  // Declare components, directives, and pipes
                    ],
                    imports: [
                      BrowserModule  // Import other modules
                    ],
                    providers: [],    // Services or providers to inject into components
                    bootstrap: [AppComponent]  // Root component that Angular bootstraps
                  })
                  export class AppModule { }


6) Interceptors - In angular inteceptors are powerfull mechanism.interceptors are powerfull feature provided by HttpClient module that allow you to intercept and modify http request and response before they sent or after they are recieved. they function is a middleware between your appliaction and backend server.
features
i) Modify request
ii) Handle response
iii) Catch errors
iv) Chain interceptors
v) Global error handling
vi) Adding authorization token to request
vii) Retrying failed request

command to create interceptors "ng g interceptor auth"

7) Directives - Directives are special classes in angular that allow you to manipulate the DOM, and modify appearence or behavior of elements. there are three types of directives:-
i) Component Directives   (A directive with a template. Technically component is a directive).
created using @Component

syntax-:
              @Component({
                  selector:'app-example',
                  template:`<p>Hello World, I am a component directive</p>`
                  styleUrl:['app-example.css']
              })

ii) Structural Directives (Change the structure/layout of the DOM. They add or remove elements from the DOM.Uses '*' prefix in templates eg. *ngIf, *ngFor, *ngSwitch).

syntax -:
          <p *ngIf='isVisible'>You can see if visible is true</p>

a) *ngIf -  Conditionally add or removes an elements from the DOM based on the boolean expression.
b) *ngFor - Repeats a block of HTML for each item in a collection.
c) *ngSwitch - Rendering different elements based on a matching conditions.

iii) Attribute Directives (Change the appearcence or behaviour of an element, Don't add or remove elemnets but alter the elements. eg. ngClass, ngStyle, ngModel).

syntax -:
      <p [ngStyle]="{color:'red',fontSize:'10px'}">Styles text</p>

a) ngClass - Dynamically applies CSS classes to an elements.
b) ngStyle - Dynamically applies inline styles to an element.
c) ngModel - Facilitates two-way data binding for form elements. 

we can create custom directives 'ng g directive highlight'

 Summary Table

                  Directive Type	       Selector Syntax	                  Purpose

                  Component	             selector: 'app-root'	             Create reusable UI blocks
                  Structural 	           *directiveName	                   Add/remove elements from DOM
                  Attribute        	      [directiveName]	                 Change appearance/behavior

8) Decorators - Decorators are a special types of functions, predefined with the '@' symbol. decorators are the way to provide extra information to a classes, methods, properties, parameters.

There are four types of decorators -:
i) Class decorators
ii) Property decorators
iii) Method decorators
iv) Parameters decorators

i) Class decorators -: Applied to class declarations to provide metadata about the class itself.
there are three types of class decorators
a) @component -: Define a class as an angular component, providing metadata like the selector, template, styles.
example - 
                    @Component({
                      selector: 'app-hello-world',
                      template: '<h1>Hello World!</h1>',
                      styleUrls: ['./hello-world.component.css']
                    })

b) @NgModule - Define a module in angular, encapsulating components, directives, services and pipes modules.

example -:
                  @NgModule({
                    declarations: [AppComponent],
                    imports: [BrowserModule],
                    providers: [],
                    bootstrap: [AppComponent]
                  })

c) @Injectable - Marks a class as available for dependency injection

ii) Property decorators - Applied to properties within a class
There are three types of properties decorators -
a) @Input() - Allowing data to be passed from parent component to a child component.Its a way to bind a value from the parent to the child component's property.
child component - 
                export class HeroComponent {
                  @Input() heroName:any;
                }

parent component -
                  <app-hero [heroName]='parentHeroName'></app-hero>                  
b) @Output() - Allowing a child component to emit events that parent can listen to. It enables two way communication.
child component - 
                   export class HeroComponent {
                     @Output() heroName = new EventEmmiter<any>();
                      sendData(){
                        this.heroName.emit('Hello world');
                      }
                    }

parent component - 
                    <app-hero (heroName)='parentHeroName($event)'></app-hero>

iii) Method Decorators - Applied to methods within a class.
There are three types of method decorators
a) @HostListener() - Allows directives and components to listen events on the host element.its useful for handling DOM events directly.
features of @HostListener 
 - Event Binding (Listens to DOM events like click, mouseenter etc..)
 - Custom DOM Event Handling (Can be used for a wide range of event handling scenarios inside    
   directives).
                            @Directive({
                              selector: '[appHighlight]'
                            })
                            export class HighlightDirective {
                              @HostListener('mouseenter') onMouseEnter() {
                                console.log('Mouse entered');
                              }

                              @HostListener('mouseleave') onMouseLeave() {
                                console.log('Mouse left');
                              }
                            }
b) @ViewChild()/@ViewChildren() - Queries for elements or components within the component's view;
iv) Parameter Decorator -  Applied to parameters within a class constructor.
- @Inject - (Manually specified a dependency to be injected).

9) Routing -  Routing in angular is a mechanism that enables navigation between different components or views within a single page apllication(SPA). It allows the application to dnamically load and display different content based on URL path,without full page relaod.
key features of routing - 
i) Angular router module - Routing functionality provided by the @angular/router module.
ii) Routes - Routes are defined as an array of objects, where each object maps a URL path to a specific component that should be displayed when that path is active.
iii) Router Outlet - The <router-outlet> directive acts as a palceholder in the application template where components associated with the active route are dynamically rendered.
iv) Router Links - The routerLink directive is used to create navigation links within the application.
v) Route Matching Strategies - Angular support different route matching strategies like - 'prefix, full'.
vi) Route Parameters and Query Params - Information can be passed between components through route parameters.
vii) Guards - Route guard can be used to control access to routes based on certain conditions (e.g. authentication,authorization).
viii) Lazy Loading - Routing can be configuared to lazy-load modules, improving initial application load times by loading the necessary code when a specific route is activated.

10) Lifecycle Hooks - Lifecycle Hooks are methods that angular calls at specific points during the lifecycle 
   of the component or directive.
   There are 8 types of lifecycle hooks - 
   i)ngOnChanges() - This hook is called whenever an input property of a component changes.its called before 
     ngOnInit().
   ii) ngOnInit() - This hook is called once the component is initialized.it runs once after the first 
       ngOnChanges, and is a good place to put intialization logic.

   iii) ngDoCheck() - This hook is called during every change detection cycle (it's called whenever angular 
        checks for changes).
   iv) ngAfterContentInit() - This hook is called once after angular has projected content into the component.
   v) ngAfterContentChecked() - This hook is called after every change detection cycle on the content 
      projected into the component.
   vi) ngAfterViewInit() - This hook is called once after the component view and child view's are initialized.
   vii) ngAfterViewChecked() - This hook is called after every change detection cycle for the component's 
        view and child views.
  viii) ngOnDestroy() -  This hook is called just before angular destroy the component. It's perfect place to clean up resources such as subscription, timers, or event listeners to avoid memory leaks.

11) Auth Guards - Auth Guards are used to protect routes by controlling the access to certain pages based on the user's authentication and authorization status. They act as 'gatekeepers' that decide if a user can 
    access a specific route or if they should be redirected to a login page or error page.auth guards are part of angular's Router module.
    there are 4 types of auth guards - 
    i) CanActivate - Decides if a route can be activated(accessed).protecting a route so only logged-in users can access it.
    ii) CanActivateChild - Protcting a parent route and all of its child routes e.g. - user profile with 
        several sections.
    iii) CanLoad - Preventing unauthorized users from even attempting to load a module.
    iv) CanDeactivate - Preventing users from accientally navigating away from a page with unsaved data e.g. 
        when user is editing a form.
     They are commonly used for authentication, authorization
        command --'ng generate guard auth'

12)  Interceptors - Interceptors are part of the HTTP client module and provide a mechanism to transform HTTP request and responses before they are sent or received.they are used to modify and handle HTTP requests and responses globally.
     interceptors are typically used for - 
    i) Adding Headers (authentication tokens)
    ii) Logging (HTTP requests and responses)
    iii) Error Handling (for HTTP requests)
    iv) Modifying request/response data
    v) Retrying failed requests
    vi) Handling authentication and authorization flows.

13) Transpiler - Transpiler is tool that converts code written in one programming language into equivalent 
    code in another language.
    in another words we can say that transpiler is a tool that convert typescript code into plain javascript, which is the language browsers understand.

    how transpilation works in angular- 
    i) TypeScript to JavaScript conversion
    ii) Bundling
    iii) Minification and Optimization
    iv) AOT (Ahead-of-Time) Compilation
    v) Source Maps

14) Difference between constructor and ngOnInit 
    In angular, both constructor and ngOnInit are used for initializing the component, but they serve different purpose and are invoked at different points in the component lifecycle.    
    i) Constructor - The constructor is part of the typescript class, and it's used for initializing class   
       properties and injecting dependencies.
       it is the first method that is called when instance of a class is created.
    ii) ngOnInit - It is a lifecycle hook that is invoked after constructor.this method is called after 
        angular has initialized all the input properties and after the first change detection cycle.
        examples include - 
       - Fetching data from api's
       - Setting up subscriptions to observables

      key differences - 

      features       constructor                                  ngOnInit()

      Origin         Standard javascript/typescrpt                Angular lifecycle hook
      Call Order     First, when the class instance is created    After the constructor and input 
                                                                  initialization
      Purpose        Dependecy injection, basic property          Complex initialization, data fetching, DOM 
                     initialization                               interaction, logic relying on @Input()  
      Input          @Input properties are not available          @Input properties are available
      Availability               

15) Difference between <ng-container> and <ng-template>
    In angular, both <ng-container> and <ng-template> are used to handle template rendering without adding extra DOM elements, but they serve different purposes.

    i) <ng-container> - is a structural directive in angular used to group elements together without adding extra DOM elements. when you  want to apply structural directives but you don't want an extra element in the DOM.(e.g div, span)
    syntax -
                  <ng-container *ngIf="isVisible">
                  <p>This content is conditionally visible.</p>
                  </ng-container>
    
    ii) <ng-template> - It defines a template block that is not rendered directly but can be initiated and  
        inserted into DOM dynamically
                          
Key Differences Summarized:
Feature         ng-container                                     ng-template

Primary Role    Logical grouping for structural directives       Defining reusable template blocks

Direct          Not rendered in the DOM                          Not rendered directly; requires instantiation
Rendering                                                                 
Usage            Applied directly with structural directives       Used with structural directives (e.g., 
                                                                   *ngIf else, *ngFor empty) or *ngTemplateOutlet

Example          html<ng-container *ngIf="condition">              html<ng-template #myTemplate>
                 <p>Content 1</p> <p>Content 2</p>                 <p>Template Content</p> 
                  </ng-container>                                  </ng-template>
                                                                   <div *ngIf="condition; else myTemplate">Main Content</div>

16) Error Hnadling - Error Handling in angular is an important aspect to ensure that your application remains stable and user-friendly even when things go wrong.Angular provides a robust mechanism to handle errors both in frontend and asynchronous operations like HTTP requests.

i) try-catch - for synchronous code, you can use the try-catch block to catch errors.
syntax - 
             try{
              const result = someFunctionThatMightThrow();
             }catch(error){
              console.log('An error occured:',error);
             }


ii) Handling Errors in observables(RxJS) - Angular uses RxJS for aynchronous programming,and you can handle errors in the observable streams using .catchError or .subscribe() error handlers.
- example with catchError operator - 

                          import { catchError } from 'rxjs/operators';
                          import { throwError } from 'rxjs';

                          // Inside your service
                          getData() {
                            return this.http.get('api/data').pipe(
                              catchError((error) => {
                                console.error('Error fetching data:', error);
                                return throwError(() => new Error('Error fetching data'));
                              })
                            );
                          }

- example with .subscribe() error handling -  

                          this.myService.getData().subscribe({
                            next: (data) => {
                              // Handle data
                            },
                            error: (err) => {
                              console.error('Error occurred:', err);
                            }
                          });

Summary - 
i) Use try-catch for synchronous error handling.
ii) Use .catchError and .subscribe() for handling errors in Observables.(for asynchronous programming)
ii) Use the ErrorHandler class for global error handling.
iv) Use HTTP interceptors to handle HTTP errors globally.
v) Use built-in Angular form validation for handling form-related errors.
vi) Customize error messages based on the error type to improve UX.

17) Types of compiler - compilers is tool that converts code written in one programming language into  
    equivalent code in another language.
    in another words we can say that compiler is a tool that convert typescript code into plain javascript, which is the language browsers understand.
Angular primarily utilized two types of compilation 

i) JIT (Just-in-Time) - (compilation at runtime)
ii) AOT (Ahead-of-Time) - (compilation at build time)

i) JIT (Just-in-Time) - The Just-in-Time Compiler compiles the application in the browser at runtime.When the user access the application, JIT compiler translate typescript and templates into executable javascript in the user's browser.

execution flow - 
a) Browser loads the application - The app's typescript code, templates, and other assets are loaded by the 
  browser.
b) JIT compiles -  During execution, the JIT compiler compiles the components, directives, pipes, and 
  templates in the browser, converting them into javascript code that the browser can run.
- Compilation at runtime
- Faster development
- Debugging is  easy
- Slower initial load
- Larger bundle size
- Not optimal for production

ii) AOT (Ahead-of-Time) - The AOT compiler compiles the angular application during the build process,before it is sent to the browser.
execution flow - 
a) Development build process - During the build time, Angular's AOT compiler analyze the entire application 
   and compiles the templates and components into executable javascript code.
b) Ready to production - The compiled javascript code is then bundled and minified ready to be served to 
   the user.
- Compilation at build time
- Faster rendering
- Faster initial code
- Smaller bundle size
- Better performance
- Early Error detection
- Slower build times
- Harder to debug
- Production environment

Key Differences Between JIT and AOT Compilers - 

| Feature               | **JIT Compiler**                                     | **AOT Compiler**                                         |
| --------------------- | ---------------------------------------------------- | ----------------- |
| **Compilation Time**  | Compilation happens **at runtime** in the browser.   | Compilation happens **at build time** before deployment. |
| **Development Speed** | Faster development because of real-time compilation.          | Slower development due to pre-compilation.               |
| **Performance**       | Slower startup and runtime performance due to runtime compilation. | Faster startup and better performance.                   |
| **Bundle Size**       | Larger bundle because the Angular compiler is included.            | Smaller bundle as the compiler is not included.          |
| **Error Detection**   | Errors are detected at **runtime**.                                | Errors are detected at **build time**.                   |
| **Debugging**         | Easier to debug since templates are not precompiled.               | Harder to debug since templates are precompiled.         |
| **Usage**             | Best for **development** environments.                             | Best for **production** environments.                    |
                  |


18) Dependency Injection -  DI in angular is a fundamental design pattern that allows classes to receive their dependencies from external sources rather than creating them internally.This promotes loose coupling, enhances testability, and improve code organization and reusability.
* The DI system provides objects or services to classes (like component, services,or directives) by the constructor.
* @Injectable() decorator  : This decorator tells angular that this class can be injected as a dependency.The providedIn : 'root' means the service is available globally(app-wide) as a singleton.

         import { Injectable } from '@angular/core'
         @Injectable({
          providedIn: 'root' //this makes the service s singleton in the app
         })
         export class MyService{
          constructor(){
            console.log("NyService is created");
          }
          getUser(){
            return {name:"Bhavna",age:25};
          }
         }

19) Subject and BehaviourSubject - 

    Subject - A Subject is a type of Observables that allows multicast(sending values to multiple subscribers) while maintaining its state. Both are powerful tools in RxJS.
    Key characterstics - 
    * Multicasting - When you subscribe to a 'Subject', all the subscribers will receive the same emmitted values.
    * No Initial Value - A 'Subject' does not maintain any internal state,so if a subscriber subscribe after a value emmitted, it will not receive the previous value - it will only receive new values that are emmitted after it subscribe.
    * Can emit new values - You can call next() method on the subject to emit new values. 
   syntax - private mySubject = new Subject<number>();

   BehaviourSubject - It is a varient of 'Subject', and it requires initial value. It remebers the most recent value and will immidiately send that value to any new subscriber, ensuring that they don't miss any data.
   Key characterstics - 
   * Multicasting - Similars to 'Subject' it can broadcast the emmitted to multiple subscribers.
   * Requires initial value - Must provide initial value when creating a 'BehaviourSubject'.
   * Remembers last value - It stored last emmitted value and sends it to any new subscriber.
   * Stateful - It holds its latest value an will emit that value immediatly when a new subscriber subscribes. 
    syntax - private SubjectBehaviour = SubjectBehaviour<any> = new SubjectBehaviour<any>("0"); // Initial value is 0
        or - private SubjectBehaviour = new SubjectBehaviour<any>(""); // Initial value is 0

| Feature                 | **Subject**                                                                            | **BehaviorSubject**                                                                       |
| ----------------------- | -------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **Initial Value**       | No initial value                                                                       | Requires an initial value                                                                 |
| **Last Emitted Value**  | Does not store the last emitted value                                                  | Always stores and re-emits the last value                                                 |
| **Subscriber Behavior** | New subscribers will not receive any previously emitted values                         | New subscribers receive the last emitted value immediately                                |
| **Typical Use Cases**   | Used when you don't need to keep track of the latest value (e.g., broadcasting events) | Used when you want the latest value available to new subscribers (e.g., state management) |

20) Observables - For handling asynchronous data, Observables and subscriptions are fundamental concepts. An Observable is a stream of data or events that you can subscribe to, and it represents asynchronous operation over time. Observables can emit values and these values can be of type (such as numbers, objects, or even errors).
Observables is like a data source that can produce values over time such as : 
* User Input events (like clicks or key presses).
* HTTP responses (like data from a REST API).
* Timer or intevals
* WebSocket messages.
* Any other asynchronous events.
* Emit a value immediately or over time. 
                import { Observable } from 'rxjs';

                const observable = new Observable<number>((observer) => {
                  observer.next(1);  // Emit value 1
                  observer.next(2);  // Emit value 2
                  observer.next(3);  // Emit value 3
                  observer.complete(); // Signal that the Observable is finished
                });

21) Subscribe - The process of 'listening' to an observable.A subscription in RxJS represents the act of subscribing to an observable to receive its emmitted values.When call subscribe() on an observable, you are :
* Starting the execution of the observable.
* Handling any values that it emits.
* Receiving notifications of completion or errors.               
            observable.subscribe({
              next: (value) => console.log('Received value:', value),
              error: (err) => console.error('Error occurred:', err),
              complete: () => console.log('Observable completed')
            });

* next: This is called each time the Observable emits a new value.
* error: This is called if the Observable encounters an error.
* complete: This is called when the Observable completes (when no more values will be emitted).

In a nutshell:
* Observable is like a TV station broadcasting data.
* Subscribe is like tuning in to the TV station to watch the broadcast.
22) interceptors
23) How do you create custom directives 
24) Component Interaction
25) How to manage large data sets in Angular (pagination, virtual scrolling,store in service,localstorage and sessionstorage).
26) Rxjs operators

27) Crud in angular - 
  üëâ CRUD in Angular is implemented using HttpClient through services to create, read, update, and delete data from backend APIs using Observables.
 CRUD stands for:
  ‚úî Create   (Create Service (API Layer ‚Äì Best Practice) üìÅuser.service.ts)CREATE ‚Äì Add Data (Reactive Form)
  ‚úî Read     (READ ‚Äì Get & Display Data Data üìÅuser.component.ts,üìÅuser.component.html)
  ‚úî Update    (UPDATE ‚Äì Edit Data by userId)
  ‚úî Delete    (DELETE ‚Äì Remove Data by userId)

28) Entry point and exit point in angular  -  index.html
                                                  ‚Üì
                                                main.ts
                                                  ‚Üì
                                                AppModule
                                                  ‚Üì
                                                AppComponent
üîπ ngOnDestroy() ‚Äì Exit Point of Component
29) Authentication and Authorization - 
   üëâ Authentication = WHO you are - It verifies user identity using: (Username & password, OTP, Token, Biometrics).
   Authentication Flow (Angular + Backend) : Login Form
                                                ‚Üì
                                              Backend verifies credentials
                                                ‚Üì
                                              JWT token generated
                                                ‚Üì
                                              Token stored (localStorage/sessionStorage)
                                                ‚Üì
                                              User authenticated

   üëâ Authorization = WHAT you are allowed to do - Happens after authentication.Authorization controls access.
   üëâ Authentication is the process of verifying the identity of a user, while Authorization is the process of determining what resources or actions a user is allowed to access based on their authenticated identity.

| Feature | Authentication      | Authorization        |
| ------- | ------------------- | -------------------- |
| Meaning | Who you are         | What you can do      |
| Order   | First               | After authentication |
| Example | Login               | Role access          |
| Failure | Invalid credentials | Access denied        |
| Data    | Token               | Roles/permissions    |
