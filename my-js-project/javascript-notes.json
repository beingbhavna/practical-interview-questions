                          JavaScript
                       ===================


1) JavaScript - Javascript is a high-level interpreted programming language,primarily used for creating 
   dynamic and interactive content in web-pages. ite was developed in 1990s.

Key aspects of javascript - 

i) Client-Side Scripting - It runs in the browser (client-side) allows for manipulating of the DOM, handling 
   user events (like clicks and form submissions),creating animations, and updating content without requiring a full page reload.
ii) Server-Side Development - With environment like Node.js. JavaScript can also be used for server side 
    development, enabling the creation of web servers,interacting with databases, and building full-stack application.
iii) Versatility - Beyond web development, javascript is also used in areas such as mobile app development  
     (with framework like React Native), desktop applications (with Electron), and game development.
iv) Ecosystem - Javascript boosts a vast ecosystem of frameworks and libraries (e.g. React,Angular, Vue.js,
    jQuery,Express.js) that provide pre-build functionality.
v) Integration - It integrates seamlessly with HTML (for structure) and CSS (for styling) to create a complete 
   and interactive web experience.
vi) Asynchromous Nature (Non-Blocking)
vii) Object-Oriented and Functional
viii) Runs in the browser

2) JavaScript Evaluation - 
i) Evaluation of expressions in js - (In js expressions are evaluated in a specific order to produce a result. 
   these can be a simple expressions like numbers, or complex expressions like function calls,assignments and conditionals. let a = 5 + 10; )
ii)  Execution context and call stack -(The environment where code runs and how functions are placed on the call stack)
iii) Hoisting - (How declarations are moved to the top of their scope).
iv) Scope and Lexical environment - (How variables are evaluated on their scope).
v) Event Loop - (Manages asynchronous code execution).
vi) Closures - (Functions retaining access to their lexical scope).

3) ES6 - ES6 is also known as ECMAScript 2015,is the 6th edition of ECMAScript standard. it aims to make the language more powerful, easier to work with, and improve performance.
Key features of ES6 - 

i) Let and Const
 - let - Block scoped variable declaration.it provides better control over variable scope compared to var.
 - const - Also block scoped, but the value assigned to a 'const' variable can not be changed.
                let x = 5;    // Can be reassigned
                const y = 10;  // Cannot be reassigned

ii) - Arrow Function(=>) - Arrow function provide a more concise syntax for writing functions.
          const add = (a, b)=> a + b;
          const greet = name =>`Hello ${name}`;

iii) Template Literals(Template String) - Template literals allow embedding expression inside strings using ${} and support multi-line strings.
       const name='Bhavna Sharma';
       const greeting = `Hello ${name}`;
       const multiline = `This is
       a multiline string.`;

iv) Destructuring - Destructuring is a convenient way to extract values from arrays or objects into variables.
- Array Destructuring - const arr = [1,2,3,4];
                        const[a,b]=arr;   //a = 1, b = 2     
- Object Destructuring  - const person = {name:'Bhavna',skill:'Angular'};
                          const {name,skill} = person; //name='Bhavna',skill='Angular'
v)Default Parameters - ES6 allows setting default values for function parameters.
                       const greet=(name='Bhavna')=>`Hello ${name}`;
                       console.log(greet());
vi) Rest and Spread Operators - 
- Rest - (...):Collects all the reamining arguments into an array.
          const sum = (...numbers) => numbers.reduce((a,b)=>a+b,0);
          console.log(sum(1,2,3,4));  //output: 10

- Spread - (...):Expands an array or object into individual elements.

eg - spread in array - const arr1 = [1,2];
                       const arr2 = [...arr1,3,4];
                       cnsole.log(arr2); //output :[1,2,3,4]

eg. - spread in object - const person = {name:'Bhavna',skill:'Angular'};
                         const updatePerson = {...person,skill:'.net'};
                         console.log(updatePerson);  //output : {name:'Bhavna',skill:'.net'}

vii) Classes - ES6 introduces a class syntax for object oriented programming
viii) Modules (Import/Export) -ES6 supports modularity in JS with import and export. this allow you can breake your code in reusable modules.
ix) Promises -  Promises provide a cleaner way to handle asynchronous operations,making it easier to manage.
x) Map and Set - ES6 introduce two new collection types.
- Map - A collection of key-value pairs.
                  const map = new Map();
                  map.set('name', 'Alice');
                  console.log(map.get('name'));  // Outputs: Alice
- Set - A collection of unique values.
                const set = new Set();
                set.add(1);
                set.add(2);
                set.add(1);  // Won't add duplicate values
                console.log(set);  // Outputs: Set {1, 2}

4) Contructors - Before ES6 JS didn't have a build-in class syntax.We used constrctor functions to create objects.A constructor is a special method used within a class to create and initialize objects.It is automatically called when a new instance of the class is created using 'new' keyword.
Key characterstics - 
i) Initialization - The purpose of a constructor is to set up the initial state of a newly created object.
ii) 'this' keyword - Inside a constructor, 'this' keyword refers to the newly created instance of the class.
iii) 'new' keyword - Creates a new empty object.returns the new object( unless the constructor explicitly returns another object).
example -
                        class Person {
                          constructor(name, age) {
                            this.name = name;
                            this.age = age;
                          }
                          introduce() {
                            console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
                          }
                        }
                        const john = new Person("John Doe", 30);
                        john.introduce(); // Output: Hello, my name is John Doe and I am 30 years old.

5) Constant - 'const' isused to declare constants, which are variables whose values can not be reassigned after their initialization.It is part of ES6 (ECMAScript 15) and offers better control over variable mutability compared to 'var' and 'let'.
 syntax - const variableName = value;
 -'const' is followed by variable name and then the value.

Characterstics of const - 
i) Block Scoping - Just like let , const is block scoped, variable exists only within the block, where it is declared.
 eg.                  {
                          const name = "Alice";
                          console.log(name);  // Output: Alice
                      }
                      console.log(name);  // ReferenceError: name is not defined

ii) Cannot Be Reassigned - Variable declared with const can not be reassigned once they have been initialized.


Comparison between const, let and var - 

i) var -
     - Function-scoped or globally scoped.
     - Can be re-declared and re-assigned.
     - Hoisted with an initial value of undefined.
ii) let - 
     - Block-scoped.
     - Can be re-assigned but not re-declared in the same block.
     - Hoisted but stays in the teporal dead zone until initialization.
iii) const - 
     - Block-scoped.
     - Can not be re-assigned or re-declared on the same block.
     - Hoisted but stays in the temporal dead zone until initialization.     


| Feature       | `var`                           | `let`                 |`const`             |
| ------------- | ------------------------------- | ----------------------| -------------------|
| Scope         | Function/Global                 | Block                 | Block              |
| Reassignable  | Yes                             | Yes                   | No                 |
| Hoisting      | Yes, initialized as `undefined` | Yes, stays in TDZ     | Yes, stays in TDZ  |
                                                    until initialized       until initialized
| Redeclaration | Yes                             | No                    | No                 |

6) TDZ (Temporal Dead Zone) - Temporal Dead Zone in javascript refers to a specific period during the execution of the code where variables declared with the 'let', 'const' keywords are inaccessible.
This zone exists between the begninning of the scope( typically a block) where the variable is declared and the actual point of its declaration and initialization within that scope.

in another words we can can say that The Temporal Dead Zone ia a behaviour that occurs in javascript when trying to access variablea declared with 'let', 'const' before they are initialized

console.log(a); //ReferenceError: can not access 'a' before initialization
let a = 10; 

console.log(b); //ReferenceError: can not access 'b' before initialization
const b = 10;

console.log(b); //undefined
var b = 10; 

7) Hoisting - Hoisting is a behaviour in javascript where variable, function and class declarations are moved to the top of their scope during the compilation phase before the code is executed.
- This means that you can use variable and functions before they are declared in your code.
- Only declarations are hoisted not the initialization and assignment.
- 'var' keyword is hoisted, but 'let' keyword is not hoisted.

function hoisting - sayHello(); //output : 'Hello, world'
                 function sayHello(){
                  console.log('Hello, world');
                 }

            console.log(sayHello()); //output : TypeError : sayHello is not a fuction
            var sayHello(){
              console.log('Hello,world');
            }
              
8) IIFE - IIFE stands for Immediate Invoked Function Expressions.IIFE is a javascript function that is defined and executed immediate after its creation.primary purpose of an IIFE is to create a new scope for variables and functions.
syntax -       (function(){                                        (() => {
                 //code inside the function                            // Code inside the function
               })();                                                 })();  
                                                                 

               
- The function is wrapped in parathesis to treat it as an expression.
- The final () immediately invoked the function after its definition.

                (function(){
                  var name='Bhavna'; // 'name' is now scoped within the IIFE
                  function greet(){
                    var message = 'hello';
                    console.log(message + ' '+name);
                  }
                  greet();
                })();

9) Curring Function - Curring is a technique of a function that takes multiple arguments in to a series of functions that take one argument at a time.

e.g. -      function curry(func){
             return function(a){
                return function(b){
                  retun func(a,b);
                }
              } 
            }

            function add(a){
              return function(b){
                return a+b;
              }
            }
            const add5 = add(5); //add(5) returns a function that takes b
            console.log(add5(10)); // 15, because 5 + 10 = 15

 curring with arrow function - const add = a => b => c => a + b + c;    
                               console.log(add(1)(2)(3));    //6     

10) call(), apply() and bind()   - These are functions in JS that allows you to explicitly st the 'this' value for a fuction, and in some cases, pass arguments to the function.

 call() -  The call() method invoked immediatly, and passing arguments as an object.
 syntax -   func.call(thisArg, arg1, arg2, ...) 
 e.g. -         function greet(name,age){
                  console.log(`Hello, my name is ${name} and I am ${age} years old`);
                }                              
                const person = {
                  name:'Bhavna'
                }
                greet.call(person, 'Sharma', 25);
                //output : "Hello, my name is Sharma and I am 25 years old."

 apply() - The apply() method is same as call() method, but it takes an array (or an array-like object) as 
           the socond argument instead of individual arguments. (accept agument as an array).
 syntax - func.apply(thisArg, [arg1, arg2,....])
        e.g. - function greet(name,age){
                  console.log(`Hello, my name is ${name} and I am ${age} years old`);
                }                              
                const person = {
                  name:'Bhavna'
                }
                greet.call(person, ['Sharma', 25]);
                //output : "Hello, my name is Sharma and I am 25 years old."

bind() - The bind() method does not execute the function immediatly.instead, it returns a new function 
         that you can invoke later.
syntax - const newFunc = func.bind(thisArg, arg1, arg2,....) 
e.g. -                function greet(name.age){
                        console.log(`Hello, my name is ${name} and I am ${age} years old`);
                      }
                      const person = {
                        name:'Bhavna'
                      }
                      const newGreet = greet(person, 'Sharma');
                      newGreet(25); //output : "Hello, my name is Sharma and I am 25 years old".

11) undefined, undeclared and null - 
 i) undefined - It is a primitive value in JS. It means variable has been declared but not initialized with a value, or a function did not return a value.typeOf 'undefined' and returns 'undefied'.
 undefined is the default value for uninitialized variable and properties.
 Its automatically assigned by javascript when - 
 - A variable is declared but not assigned a value      
 - A function doesn't explicitly return a value
                 let a;
                console.log(a); // Output: undefined (variable is declared but not assigned)

                function noReturn() {}
                console.log(noReturn()); // Output: undefined (function does not return anything)

                let obj = {};
                console.log(obj.someProp); // Output: undefined (property doesn't exist)
ii) undeclared - An undeclared variable that has not been defined in the current scope.It means you have not even declared the variable using let,const, or var.If you try to access an undeclared variable, JS will throw a ReferenceError.
undeclared is when a variable does not exist in the current scope at all.
              console.log(a); // ReferenceError: a is not defined (variable is undeclared)
iii) null - null is another primitive value in JS, but is represents intentional absence or emptiness.(typeOf null is object).


| **Concept**              | **`undefined`**       | **`undeclared`**         |**`null`**         |
| ------------------------ | -------------------------------------------------------------------- | 
| **Definition**           | A value assigned to variables that are declared but not initialized. | A variable that has not been declared in the current scope.     | A primitive value representing intentional "emptiness".       |
| **Type**                 | `undefined` (primitive type)                                         | Not a valid type (variable doesn‚Äôt exist yet).                  | `object` (due to a JavaScript quirk)                          |
| **When does it occur?**  | - Variable declared but not assigned a value.                        | - Variable is used before declaration.                          | - Explicitly assigned to indicate "no value".                 |
| **Example**              | `let a; console.log(a); // undefined`                                | `console.log(b); // ReferenceError: b is not defined`           | `let obj = null; console.log(obj); // null`                   |
| **Comparison to `null`** | `undefined` is typically for variables with no value set.            | `undeclared` refers to variables that haven't been created yet. | `null` is for explicitly setting a variable to have no value. |


12) window and globalThis - 
   window - In a browser environment 'window' is a global object that represents browser's window.window holds all the global variables and functions, as well as a variety of properties related to the browser(such as document,location,alert, window.document, window.localStorage).any variable and function declared in the global space(without 'let', 'var' or 'const'). e.g.   -  let a = 5;
                                console.log(window.a);  //output : 5

   console.log(this === window); // Output: true (in non-strict mode, `this` in global context refers to `window`)

globalThis - It is a standarized way to refer to the global object, regardless of the javascript runtime environment.In browser 'globalThis' behaves the same as window, but in other environment (like node.js).

      console.log(globalThis); // Logs the global object, whether in a browser or Node.js
        // In the browser, this would be the same as:
        console.log(window === globalThis); // Output: true

i) In browser - 
 -  'window' is the global object and 'this' in the global scope refers to window.
 -  'globalThis' behaves the same as window in the browser.

 ii) In Node.js - 
 - 'window' does not exist (because it's a browser concept).
 - 'globalThis' refers to the global object (global in Node.js). 

13) Higher order function - A higher order function is a function that either : 
    - Takes one or more functions as arguments,
    - Returns a function as a result.
These higher order function is more powerfull because they allow you to work with functions in a flexible and reusable way.Higher order functions are commonly used in functional programming.
i) Function that takes another function as an argument :
                  function applyOperation(a,b,operation){
                    return operation(a,b);
                  }

                  function add(x,y){
                    return x + y;
                  }

                  function multiply(p,q){
                    return p * q;
                  }
                 console.log(applyOperation(5,3,add)); //8
                 console.log(applyOperation(5,3,multiply)) //15 

     applyOperation is a higher order function that takes a function add and multiply as an argument.They are very useful in many patterns like - callbacks, curring, and function composition.

 14) Deep copy and Shallow copy -              

 üëâ A shallow copy duplicates only the top-level properties, while a deep copy duplicates all nested   
     objects, creating a fully independent copy.

 i) Shallow copy - A shallow copy creates a new reference to the same object or array, meaning it copies only first level of the object and array.If the original object contains nested objects, the shallow copy will point to the same nested objects.Hence if you modify a nested object in the shallow copy the original object will also affected.   
                        const original = {name:'Bhavna',address :{city:'Noida'}};
                        //shallow copy using object.assign()
                        const shallowCopy = object.assign({},original);
                        //modify the nested object in shallow copy
                        shallowCopy.address.city = 'Gurugram';
                        console.log(original.address.city); //output : 'Gurugram'
                        console.log(shallowCopy.address.city); //output : 'Gurugram'
shallow copy methods - object.assign() for objects
                     - slice(), concat(), and (...) spread operator for arrays.    
Shallow copy is fast and efficient when you don't need deep cloning (e.g., when there are no nested structures or when you're working with immutable data).

ii) Deep copy - A deep copy creates a new object or array,and recurively copies all nested objects or arrays as well,we can say that nested structures are also duplicate.Changes to any part of the deep copy will not affect the original object because the copy is entirely independent.
                        const original = {name:'Bhavna',address:{city:'Noida'}};
                        //create deep copy
                        const deepCopy = JSON.parse(JSON.stringify(original));
                        //modify the nested object of deepCopy
                        deepCopy.address.city = 'Gurugram';
                        console.log(original); //Noida
                        console.log(deepCopy); //Gurugram
Deep copy is essential when you need to work with objects or arrays that have nested structures and want to ensure that the original data is unaffected by changes in the copied structure.

iii) Rest operator (...)- The rest operator is used to collect remaining properties or elements from an object or array in to a new object and array.
for objects : It collects all remaining properties into a new object.
for array : It collects remaining elements into a new array.
      const person = {name:'Bhavna', age:25, city:'Noida'};
      //Rest operartor in object destructuring
      const {name, ...rest} = person;
      console.log(name) //Bhavna
      console.log(rest); //{age:25,city:'Noida'}

iv) Spread operators (...) - The spread operator is used to spread out the elements or properties of an object or array into another object or array.It is used for creating copies, merging objects or arrays, or adding new properties.
for objects : It copies top-level properties of an object.
for arrays : It copies all elements of array.
       const original = { name: 'John', address: { city: 'New York' } };
      // Shallow copy using the spread operator
      const shallowCopy = { ...original };
      shallowCopy.address.city = 'San Francisco';
      console.log(original.address.city);  // San Francisco
      console.log(shallowCopy.address.city); // San Francisco

Summary of Differences:
Shallow Copy : Copies the top-level properties and keeps references to nested objects.
Deep Copy : Copies everything, including nested objects/arrays, ensuring no references to the original data.
Rest Operator : Used for collecting properties or arguments, not copying.
Spread Operator : Used for copying and spreading values, creates shallow copies.

15) Callback function - A callback() function is simply a function that is passed into another function as an argument and is executed later, when asynchronous task is completed. callback function is a higher order function.
 - It is passed as  arguments.
 - executed later
 - can be synchronous or asynchronous 
    * synchronous callbacks are execute immediatly.
    * asynchronous callback, the function is executed immediatly after an asynchronous operations, like an   
      HTTP request or timer
callback functions are used for 
* Asynchronous Programming
* Event Handling
* Customization      

16) Promise - A promise is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value.
üëâ Its used to handle asynchronous operations.A Promise represents a single future value that will be either:
- Resolved (success)
- Rejected (failure)
üëâ Executes immediately when created.cannot be cancelled or unsubscribed.
A promise is like a placeholder for a value that is not yet available but will be at some point in the future.
üëâ once a promise is created, you need to handle it using then(), catch(), or finally().

Features- 
* Readable
* Chaining
* Error handling
* States

there are three states of promise
i) Pending - The initial stage of promise. The operation is still ongoing, and the promise has not been 
   fulfilled or rejected.
ii) Fulfilled - The operation completed successfully, and promise has been resolved with a resulting value.
iii) Rejected - The operation is failed, and promise is rejected with an error or reason.

     const myPromise = new Promise((resolve,reject)=>{
      const success = true;
      if(success){
        resolve("Operation was successful!");
      }else{
        reject("Something went wrong.");
      }
     });

methods - 
* .then() - Handles resolved values.
* .catch() - Handles rejection or errors.
* .finally() - Executes regardless of success or failure.
- Async/Await with promises -  

           async function fetchData(){
            try{
              const response = await fetch("https://jsonplaceholder.typicode.com/posts");
              const data = await response.json();
              console.log(data);
            }catch(error){
              console.log("Error",error)
            }
           }
           fetchData();

üîπ Real-Life Example üß†
üì¶ Online Order Delivery
  - Order placed
  - Delivered once
  - Promise completed
17) Difference between promise and callback() - 
   * Callback - you are working with older codebases or libraries that use callback.
              - callback() handle simple asynchronous tasks, and the flow is not deeply nested.
   * promise  - You are working with modern javascript.
              - promise handle asynchronous operations in a cleaner and more structured way.
              - promise handle multiple asynchronous operations and want to avoid callback hell.
              - use async/await for cleaner syntax.           

| **Aspect**                        | **Callback**        | **Promise**     |
| --------------------------------- | ------------------- | ---------------- |
| **Nature**                        | Function passed as an argument                           | Object representing eventual completion of async task         |
| **Error Handling**                | Manually via error-first callback                        | Built-in `.catch()` method                                    |
| **Syntax**                        | Can lead to nested, hard-to-read code (callback hell)    | Cleaner syntax with `.then()`, `.catch()`, and `.finally()`   |
| **Asynchronous Flow**             | Complex when handling multiple async tasks               | Easier with `.then()`, `.all()`, `.race()` for parallel tasks |
| **Use with `async/await`**        | Can't directly use with `async/await` without conversion | Works seamlessly with `async/await`                           |
| **Execution Order**               | Synchronous unless explicitly handled                    | Sequential, can be chained                                    |
| **Readability & Maintainability** | Can become hard to maintain with nested callbacks        | More readable and maintainable                                |

18) Typed Language - A typed language is a programming language.It is associate with values and not with variables.In a typed language, variables and exppressions have types (such as numbers, strings, booleans etc..).
There are two types of typing system - 
i) Static Typing (or strong typing) - 
  * Type checking is done at compile time.
  * Variables must be explicitly declared with their type.
  * Once a variable is assigned a type, it cann't change to another type during runtime.
  * the variables can hold only one type like in java, a variable declared of string it can take characters only nothing else.
ii) Dynamic Typing (or weak typing) -
   * Type checking is done at runtime, not compile time.
   * Variable can change types as the program runs, based on the value they are assigned.
   * You don't need to declare the type of variable explicitly.
   * The varibale can hold multiple types like JavaScript, a variable can take number, characters etc.


19) Javascript Fundamentals - javascript fundamentals are the core concepts and features of the language that are essential to understanding how to write,debug, and maintain javascript code.

i) Variables and Data Types
 * Variables - Store values (e.g. let, const, var).
 * Primitive Data Types - 
   - string : Text data e.g. "Hello".   ( let name = "Alice";)
   - number : Numeric data e.g. 23,34,45.6     (const age = 25;)
   - boolean : true or false   (let isActive = true;)
   - undefined : A variable that has not been assigned a value.
   - null : A delibirate non-value.
   - symbol : Unique idetifires (New in ES6).
   - bigint : For large integer.

ii) Operators -  
 * Arithmetic Operators (+, -, *, /, %, ++, --)   
 * Assignment Operators (=, +=, -=, *=, /=)
 * Comparison Operators (==, ===, !=, !==, <, >, <=, >=)
 * Logical Operators (&&, ||, !)
 * Ternary Operators (condition ? expr1 : expr2)

iii) Control Structures
 * Conditionals : if, else if, else, switch
 * Loops : for, while, do....while, forEach (array-specific)

iv) Functions - 
 * Function Declarations - A reusable block of code.
 * Function Expression : Functions assigned to varianles.
 * Arrow Functions (ES6) : Concise syntax for functions.
 * Parameters and Return Values : Functions can accept input and out result.

v) Arrays -
 * Collections of values
 * Array Methods : push(), pop(), shift(), unshift(), map(), filter(), reduce().
 
vi) Objects -
 * Collections of key-value pairs.
  * Can contain primitive types, arrays, or other objects.

vii) Scope and Closures
 * Global Scope : Accessible anywhere in the code.
 * Function Scope : Accessible only inside the function.
 * Block Scope : With  let and const variable are limited to the block(enclosed by { }).
 * Closure : A function that "remembers" its lexical scope even when executed outside that scope.
 
viii) Asynchronous Javascript
 * Callback : Functions passed as arguments to other functions.
 * Promise : Used to handle asynchronous operations.
 * Async/Await : Cleaner syntax for dealing with promises.

 promise example -                  const fetchData = new Promise((resolve,reject)=>{
                                      setTimeout(()=>resolve("Data Fetching...."),1000);
                                     });
                                     fetchData.then((data)=>console.log(data)); //data fetched

Async/Await example -              async function fetchData(){
                                    let response = await fetch("https://api.example.com");
                                    let data = await response.json();
                                    console.log(data);
                                    }                                     

ix) Error Handling - 
 * Try/Catch : Used to handle exceptions.

x) DOM Manipilation (for web development)
 * Selecting Elements : document.getElementById("id"), document.querySelector().
 * Changing Content : innerHTML, textContent.
 * Event Listener : addEventListener()

xi) ES6+ Features -
 * Template Literals : String interpolation using backtick(``).
 * Destructuring : Extract values from arrays or objects.
 * Spread and Rest Operators : (...)
 * Modules : import and export. 

xii) Classes and inheritance - 
 * Classes : Used for object-oriented programming.
 * Constructor & Methods : Define the properties and actions for an object.
 * Inheritance : Classes can inhert from other classes.

 xiii) Evant Loop
 
20) async and await in JavaScript/TypeScript
i) async Function - An async function is a function that always returns a Promise. The async keyword is used to declare such functions, and it allows the use of await inside them.
   Syntax:  async function myFunction() {
             // Function logic here
            }
Behavior: When you call an async function, it automatically returns a Promise. If the function returns a value, the Promise resolves with that value. If the function throws an error, the Promise is rejected with that error.

ii) await Expression - The await keyword can only be used inside an async function. It makes JavaScript wait for a Promise to resolve or reject before moving on to the next line of code.
Syntax: let result = await someAsyncFunction();

Behavior: * await pauses the execution of the function until the Promise is settled (either resolved or rejected).
        * If the Promise resolves, it returns the result, which can be assigned to a variable.
        * If the Promise rejects, it throws an error, which can be caught using a try-catch block.

- async functions always return a Promise.
- await can be used inside async functions to wait for the resolution of a Promise and simplify working with asynchronous code.



21) write a program to reverse string without using build-in methods
        function reverseString(str) {
          let reversedStr = '';
          // Start at the last character and move towards the first
          for (let i = str.length - 1; i >= 0; i--) {
              reversedStr += str[i];
          }
          return reversedStr;
      }
      const originalString = 'Bhavna';
      const resultString = reverseString(originalString);
      console.log(resultString);  // Output: 'anavhB'
22) Static and Dynamic type in js
23) Which type of JS static or dynamic
24) let, var, const 
25) clousure in js with example - A closure allows a inner functions can access variables of outer functions, even after the outer function has finished execution.
                                        function outer() {
                                        let count = 0;

                                        return function inner() {
                                            count++;
                                            console.log(count);
                                        };
                                        }

                                        const counter = outer();
                                        counter(); // 1
                                        counter(); // 2
                                        counter(); // 3
 - Why Closures Are Important
   * Data hiding (encapsulation)
   * Used in callbacks, promises, event handlers
   * State management
   * Factory functions
 26) Observables -   An Observable is a stream of multiple values over time.
                 üëâ Execution starts only when subscribed
                 üëâ Can be cancelled
                 ‚úî Emits multiple values
                 ‚úî Lazy execution
     üîπ Real-Life Example üß†
       üì° Live Cricket Score
          - Continuous updates
          - Can stop watching anytime
          - Stream-based

| Feature   | Promise        | Observable      |
| --------- | -------------- | --------------- |
| Values    | Single         | Multiple        |
| Execution | Eager          | Lazy            |
| Cancel    | ‚ùå No           | ‚úÖ Yes        |
| Operators | Limited        | Powerful (RxJS) |
| Retry     | Manual         | Built-in        |
| Use case  | One-time async | Streams/events  |
